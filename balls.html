<!DOCTYPE html>
<html>
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="author" content="mnemonic@386dx25.de">
<style>
body {
  padding: 0;
  margin: 0;
  overflow: hidden;
  text-align: center;
}
</style>
<canvas id="screen"></canvas>
<script>
'use strict';

function DrawBuffer( canvas ) {
  this.canvas = canvas;
  this.context = this.canvas.getContext('2d');
  this.resizeAndClear = function(width, height) {
    this.canvas.width = width;
    this.canvas.height = height;
    this.context.clearRect(0,0,canvas.width,canvas.height);
    this.context.strokeStyle = 'gray';
    this.context.strokeRect(0,0,canvas.width,canvas.height);
  }
}

var buffers = [ new DrawBuffer(document.createElement('canvas')), new DrawBuffer(document.createElement('canvas')) ];
var screen = new DrawBuffer(document.getElementById('screen'));
var mod = 0; // current buffer rendered to

var ball = {
  radius : 23,
  pos : [100.0, 100.0],
  vel : [0.1, 0.1],
  hue : 0,
  bounds : [0,0, 100,100], // set in reset()
  
  reset : function(width, height) {
    this.bounds = [this.radius, this.radius, width - this.radius, height - this.radius];
    this.pos[0] = Math.floor(Math.random() * width-2*this.radius);
    this.pos[1] = Math.floor(Math.random() * height-2*this.radius);
  },
  
  move : function(dt) {
    let r = this.radius;
    let boundLo = [ this.bounds[0], this.bounds[1] ];
    let boundUp = [ this.bounds[2], this.bounds[3] ];
    for( var d=0; d < 2; ++d ) { // x,y dimensions are handled identical
      this.pos[d] += dt*this.vel[d];

      if(this.pos[d] > boundUp[d]) {
        this.vel[d] = -Math.abs(this.vel[d]);
        this.pos[d] = boundUp[d] - 1;
      }
      if(this.pos[d] < boundLo[d]) {
        this.vel[d] = Math.abs(this.vel[d]);
        this.pos[d] = boundLo[d] + 1;
      }
    }  
  },
  
  draw: function(canvas,context) {
    context.beginPath();
    context.fillStyle = 'hsl(' + this.hue + ',100%,50%)';
    context.arc(this.pos[0], this.pos[1], this.radius, 0, 2*Math.PI, false);
    context.fill();
    context.strokeStyle = 'gray';
    context.stroke();
    
    this.hue = (this.hue+10) % 360;
  }  
};

function resize() {
  const new_size = [ Math.min( window.innerWidth, 640 ), Math.min( window.innerHeight, 480 ) ]; // or full window: [ window.innerWidth, window.innerHeight ];
  const resize_needed = new_size[0] != screen.canvas.width || new_size[1] != screen.canvas.height;
  if (resize_needed) {
    [screen].concat(buffers).forEach( function(buf){
      buf.resizeAndClear(new_size[0], new_size[1]);
    });
    ball.reset(new_size[0], new_size[1]);
  }
}

let t0;
let tlast;
function update(timestamp) {
    if(t0 === undefined) {
        t0 = timestamp;
        tlast = timestamp;
    }    
    const dt = timestamp - tlast;
    if(dt > 40) { // 40ms = 25fps redraw rate
    
      ball.move(dt);
    
      ball.draw(buffers[mod].canvas,buffers[mod].context);
      screen.context.drawImage(buffers[mod].canvas, 0, 0);
      mod = (mod+1)%2;
      
      tlast = timestamp;
    }
    
    window.requestAnimationFrame(update);
}

resize();
window.addEventListener('resize', resize, false);
window.requestAnimationFrame(update); // consider setInterval() to get rid of timing code above
</script>
</html>